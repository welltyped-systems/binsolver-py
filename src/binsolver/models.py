# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2026-01-31T00:34:12+00:00

from __future__ import annotations

from enum import Enum
from typing import Annotated

from pydantic import AnyUrl, BaseModel, ConfigDict, Field


class Objective(Enum):
    fast = "fast"
    min_bins = "minBins"
    max_placed = "maxPlaced"
    min_waste = "minWaste"
    min_cost = "minCost"
    shipping = "shipping"


class LabelFormat(Enum):
    none = "none"
    zpl = "zpl"


class NestingStrategy(Enum):
    auto = "auto"
    maximize = "maximize"
    none = "none"


class Rotation(Enum):
    xyz = "xyz"
    xzy = "xzy"
    yxz = "yxz"
    yzx = "yzx"
    zxy = "zxy"
    zyx = "zyx"


class NestedPlacement(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    item_id: Annotated[
        str, Field(alias="itemId", description="Item identifier for this placement.")
    ]
    x: Annotated[
        float,
        Field(
            description="X coordinate of the placement origin (relative to container)."
        ),
    ]
    y: Annotated[
        float,
        Field(
            description="Y coordinate of the placement origin (relative to container)."
        ),
    ]
    z: Annotated[
        float,
        Field(
            description="Z coordinate of the placement origin (relative to container)."
        ),
    ]
    w: Annotated[
        float, Field(description="Packed width (includes item padding if provided).")
    ]
    h: Annotated[
        float, Field(description="Packed height (includes item padding if provided).")
    ]
    d: Annotated[
        float, Field(description="Packed depth (includes item padding if provided).")
    ]
    rotation: Annotated[Rotation, Field(description="Applied rotation permutation.")]


class UnplacedItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    item_id: Annotated[str, Field(alias="itemId", description="Item identifier.")]
    w: Annotated[float, Field(description="Item width.")]
    h: Annotated[float, Field(description="Item height.")]
    d: Annotated[float, Field(description="Item depth.")]
    weight: Annotated[float | None, Field(description="Item weight.")] = None
    reason: Annotated[
        str,
        Field(
            description="Reason code for why the item was not placed (e.g., no_fit, pallet_unplaced)."
        ),
    ]


class UnplacedPallet(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    pallet_id: Annotated[
        str, Field(alias="palletId", description="Pallet instance id.")
    ]
    reason: Annotated[
        str, Field(description="Reason code for why the pallet was not placed.")
    ]


class SplitAssignment(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    item_id: Annotated[str, Field(alias="itemId", description="Item identifier.")]
    bin_id: Annotated[
        str,
        Field(
            alias="binId",
            description="Container/bin identifier where the item ultimately lands.",
        ),
    ]
    pallet_id: Annotated[
        str | None,
        Field(
            alias="palletId", description="Pallet identifier if palletization was used."
        ),
    ] = None


class ShippingResult(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    billable_weight: Annotated[
        float,
        Field(
            alias="billableWeight",
            description="max(actual weight, dimensional weight).",
        ),
    ]
    dimensional_weight: Annotated[
        float,
        Field(
            alias="dimensionalWeight",
            description="Dimensional weight computed from bin volume and divisor.",
        ),
    ]
    cost: Annotated[float, Field(description="Estimated shipping cost.")]
    carbon: Annotated[float, Field(description="Estimated carbon impact.")]
    sla_days: Annotated[
        float, Field(alias="slaDays", description="Estimated delivery time in days.")
    ]


class AllowedEnum(Enum):
    xyz = "xyz"
    xzy = "xzy"
    yxz = "yxz"
    yzx = "yzx"
    zxy = "zxy"
    zyx = "zyx"


class RotationMode(Enum):
    any = "any"
    none = "none"
    upright = "upright"
    no_flip = "noFlip"
    axis = "axis"
    custom = "custom"


class RotationAxes(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    xy: Annotated[bool | None, Field(description="Allow swapping X and Y.")] = None
    xz: Annotated[bool | None, Field(description="Allow swapping X and Z.")] = None
    yz: Annotated[bool | None, Field(description="Allow swapping Y and Z.")] = None


class StackingRulesInput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min_support_ratio: Annotated[
        float | None,
        Field(
            alias="minSupportRatio",
            description="Minimum supported base area ratio (0..1).",
        ),
    ] = None
    min_support_area: Annotated[
        float | None,
        Field(
            alias="minSupportArea",
            description="Minimum supported base area (absolute units).",
        ),
    ] = None
    max_load: Annotated[
        float | None,
        Field(
            alias="maxLoad", description="Maximum load this item can support above it."
        ),
    ] = None
    max_stack_height: Annotated[
        float | None,
        Field(
            alias="maxStackHeight",
            description="Maximum stacked height above this item.",
        ),
    ] = None
    require_cog_support: Annotated[
        bool | None,
        Field(
            alias="requireCogSupport",
            description="Require center-of-gravity to be supported.",
        ),
    ] = None


class GroupMode(Enum):
    keep_together = "keepTogether"
    separate = "separate"


class PaddingInput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    all: Annotated[float | None, Field(description="Uniform padding on all axes.")] = (
        None
    )
    x: Annotated[float | None, Field(description="Padding on the X axis.")] = None
    y: Annotated[float | None, Field(description="Padding on the Y axis.")] = None
    z: Annotated[float | None, Field(description="Padding on the Z axis.")] = None


class ShippingInput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    base_cost: Annotated[
        float | None,
        Field(alias="baseCost", description="Fixed cost per shipment for this bin."),
    ] = None
    rate_per_weight: Annotated[
        float | None,
        Field(
            alias="ratePerWeight",
            description="Variable cost per unit of billable weight.",
        ),
    ] = None
    dim_weight_divisor: Annotated[
        float | None,
        Field(
            alias="dimWeightDivisor",
            description="Divisor for dimensional weight (volume / divisor).",
        ),
    ] = None
    carbon_per_weight: Annotated[
        float | None,
        Field(
            alias="carbonPerWeight",
            description="Carbon cost per unit of billable weight.",
        ),
    ] = None
    sla_days: Annotated[
        float | None,
        Field(alias="slaDays", description="Estimated delivery time for this bin."),
    ] = None


class ShippingObjectiveInput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    cost_weight: Annotated[
        float | None,
        Field(
            alias="costWeight",
            description="Weight applied to cost in the shipping objective.",
        ),
    ] = None
    carbon_weight: Annotated[
        float | None,
        Field(
            alias="carbonWeight",
            description="Weight applied to carbon impact in the shipping objective.",
        ),
    ] = None
    sla_weight: Annotated[
        float | None,
        Field(
            alias="slaWeight",
            description="Weight applied to SLA days in the shipping objective (lower is better).",
        ),
    ] = None
    dim_weight_divisor: Annotated[
        float | None,
        Field(
            alias="dimWeightDivisor",
            description="Override bin shipping dimWeightDivisor for optimization.",
        ),
    ] = None


class PackStats(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    items: Annotated[
        int, Field(description="Total items requested (after quantity expansion).")
    ]
    placed: Annotated[int, Field(description="Number of items successfully placed.")]
    unplaced: Annotated[int, Field(description="Number of items not placed.")]
    nested: Annotated[
        int | None, Field(description="Number of items nested inside other items.")
    ] = None
    bins_used: Annotated[
        int, Field(alias="binsUsed", description="Number of bins used.")
    ]
    pallets_used: Annotated[
        int | None,
        Field(
            alias="palletsUsed",
            description="Number of pallets used (if palletization enabled).",
        ),
    ] = None
    duration_ms: Annotated[
        int, Field(alias="durationMs", description="Packing duration in milliseconds.")
    ]
    request_id: Annotated[
        str | None,
        Field(alias="requestId", description="Echoed request id when provided."),
    ] = None


class ErrorBody(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    code: Annotated[str, Field(description="Machine-readable error code.")]
    message: Annotated[str, Field(description="Human-readable error message.")]
    request_id: Annotated[
        str | None,
        Field(alias="requestId", description="Request identifier when provided."),
    ] = None


class BinInput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Annotated[
        str | None,
        Field(description="Optional bin identifier. If omitted, the API assigns one."),
    ] = None
    w: Annotated[float, Field(description="Bin width (X axis).", gt=0.0)]
    h: Annotated[float, Field(description="Bin height (Y axis).", gt=0.0)]
    d: Annotated[float, Field(description="Bin depth (Z axis).", gt=0.0)]
    max_weight: Annotated[
        float | None,
        Field(
            alias="maxWeight",
            description="Maximum weight capacity of this bin (sum of item weights).",
        ),
    ] = None
    cost: Annotated[
        float | None,
        Field(description="Cost of using this bin (required for minCost objective)."),
    ] = None
    tare_weight: Annotated[
        float | None,
        Field(
            alias="tareWeight",
            description="Empty weight of the bin or pallet (added to shipment weight).",
        ),
    ] = None
    allow_hazmat: Annotated[
        bool | None,
        Field(
            alias="allowHazmat",
            description="If false, hazmat items cannot be placed in this bin. Defaults to true.",
        ),
    ] = None
    padding: Annotated[
        PaddingInput | None,
        Field(
            description="Clearance between items and bin walls (shrinks usable interior)."
        ),
    ] = None
    shipping: Annotated[
        ShippingInput | None,
        Field(
            description="Shipping profile for this bin (required for objective=shipping)."
        ),
    ] = None
    quantity: Annotated[
        int | None,
        Field(
            description="When set, must not exceed plan limits (free 100, paid 1000).",
            ge=1,
            le=1000,
        ),
    ] = None


class Placement(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    item_id: Annotated[
        str, Field(alias="itemId", description="Item identifier for this placement.")
    ]
    x: Annotated[float, Field(description="X coordinate of the placement origin.")]
    y: Annotated[float, Field(description="Y coordinate of the placement origin.")]
    z: Annotated[float, Field(description="Z coordinate of the placement origin.")]
    w: Annotated[
        float, Field(description="Packed width (includes item padding if provided).")
    ]
    h: Annotated[
        float, Field(description="Packed height (includes item padding if provided).")
    ]
    d: Annotated[
        float, Field(description="Packed depth (includes item padding if provided).")
    ]
    rotation: Annotated[Rotation, Field(description="Applied rotation permutation.")]
    nested: Annotated[
        list[NestedPlacement] | None,
        Field(
            description="Items packed inside this item (if nesting was used). Coordinates are relative to the item's local origin."
        ),
    ] = None


class RotationRulesInput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    mode: Annotated[
        RotationMode | None,
        Field(description="Rotation strategy. upright/noFlip keep height on Y axis."),
    ] = None
    allow_axes: Annotated[
        RotationAxes | None,
        Field(alias="allowAxes", description="Allowed axis swaps when mode=axis."),
    ] = None
    allowed: Annotated[
        list[AllowedEnum] | None,
        Field(description="Allowed explicit rotations when mode=custom."),
    ] = None


class NestingRulesInput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    inner_w: Annotated[
        float, Field(alias="innerW", description="Inner cavity width (X axis).", gt=0.0)
    ]
    inner_h: Annotated[
        float,
        Field(alias="innerH", description="Inner cavity height (Y axis).", gt=0.0),
    ]
    inner_d: Annotated[
        float, Field(alias="innerD", description="Inner cavity depth (Z axis).", gt=0.0)
    ]
    padding: Annotated[
        PaddingInput | None,
        Field(description="Clearance between nested items and cavity walls."),
    ] = None
    max_weight: Annotated[
        float | None,
        Field(
            alias="maxWeight",
            description="Maximum total weight allowed inside this cavity.",
            ge=0.0,
        ),
    ] = None
    allow_hazmat: Annotated[
        bool | None,
        Field(
            alias="allowHazmat",
            description="If false, hazmat items cannot be nested inside this cavity. Defaults to true.",
        ),
    ] = None
    allowed_groups: Annotated[
        list[str] | None,
        Field(
            alias="allowedGroups",
            description="If set, only items whose packaging.group is in this list may be nested.",
        ),
    ] = None


class PalletizationInput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    pallets: Annotated[
        list[BinInput],
        Field(description="Pallet templates used for the first packing stage."),
    ]
    allow_mixed_containers: Annotated[
        bool | None,
        Field(
            alias="allowMixedContainers",
            description="When false, all pallets must fit a single container template.",
        ),
    ] = None


class ErrorResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    error: ErrorBody


class BinResult(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    bin_id: Annotated[
        str, Field(alias="binId", description="Instance id for the packed bin.")
    ]
    template_id: Annotated[
        str, Field(alias="templateId", description="Template id from the request.")
    ]
    w: Annotated[float, Field(description="Bin width.")]
    h: Annotated[float, Field(description="Bin height.")]
    d: Annotated[float, Field(description="Bin depth.")]
    weight: Annotated[
        float | None, Field(description="Total weight of items in this bin.")
    ] = None
    shipping: Annotated[
        ShippingResult | None,
        Field(
            description="Shipping cost/weight metrics for the packed bin (if shipping profile provided)."
        ),
    ] = None
    viz_url: Annotated[
        AnyUrl,
        Field(
            alias="vizUrl",
            description="URL to replay this bin packing result in the BinSolver visualizer.",
        ),
    ]
    utilization: Annotated[
        float, Field(description="Volume utilization of the bin (0.0 to 1.0).")
    ]
    placements: Annotated[
        list[Placement], Field(description="Item placements in this bin.")
    ]
    instructions: Annotated[
        list[str] | None,
        Field(description="Step-by-step packing instructions (if requested)."),
    ] = None
    label: Annotated[
        str | None,
        Field(
            description="Generated label code (e.g. ZPL) for the bin (if requested)."
        ),
    ] = None


class PackagingRulesInput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    group: Annotated[
        str | None,
        Field(
            description="Group identifier. Items sharing the same group id are governed by groupMode."
        ),
    ] = None
    group_mode: Annotated[
        GroupMode | None,
        Field(
            alias="groupMode",
            description="keepTogether packs the entire group in the same bin (or leaves all unplaced); separate isolates the group to its own bins. Defaults to keepTogether when group is set.",
        ),
    ] = None
    hazmat: Annotated[
        bool | None,
        Field(
            description="Marks item as hazardous; requires allowHazmat=true on bins."
        ),
    ] = None
    fragile: Annotated[
        bool | None,
        Field(description="Marks item as fragile; prevents stacking weight above."),
    ] = None
    nestable: Annotated[
        bool | None,
        Field(
            description="When false, this item cannot be nested inside other items. Defaults to true."
        ),
    ] = None
    nesting: Annotated[
        NestingRulesInput | None,
        Field(
            description="Defines an internal cavity so other items may be packed inside this item."
        ),
    ] = None
    padding: Annotated[
        PaddingInput | None,
        Field(description="Clearance added around the item dimensions."),
    ] = None


class ItemInput(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Annotated[
        str | None,
        Field(description="Optional item identifier. If omitted, the API assigns one."),
    ] = None
    w: Annotated[float, Field(description="Item width (X axis).", gt=0.0)]
    h: Annotated[float, Field(description="Item height (Y axis).", gt=0.0)]
    d: Annotated[float, Field(description="Item depth (Z axis).", gt=0.0)]
    weight: Annotated[
        float | None,
        Field(
            description="Weight of a single unit of this item (used for load limits and shipping).",
            ge=0.0,
        ),
    ] = None
    allow_rotation: Annotated[
        bool | None,
        Field(
            alias="allowRotation",
            description="If true, the item can be rotated 90 degrees on any axis. Defaults to true.",
        ),
    ] = None
    rotation: Annotated[
        RotationRulesInput | None,
        Field(
            description="Detailed rotation rules (overrides allowRotation when provided)."
        ),
    ] = None
    stacking: Annotated[
        StackingRulesInput | None,
        Field(description="Stacking constraints for stability and load."),
    ] = None
    packaging: Annotated[
        PackagingRulesInput | None,
        Field(description="Grouping, hazmat, fragile, and padding rules."),
    ] = None
    quantity: Annotated[
        int | None,
        Field(
            description="When set, total expanded items must remain within plan limits (free 100, paid 1000).",
            ge=1,
            le=1000,
        ),
    ] = None


class PackResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    bins: Annotated[
        list[BinResult], Field(description="Packed bins (containers) with placements.")
    ]
    pallets: Annotated[
        list[BinResult] | None,
        Field(description="Packed pallets when palletization is enabled."),
    ] = None
    unplaced: Annotated[
        list[UnplacedItem], Field(description="Items that could not be placed.")
    ]
    unplaced_pallets: Annotated[
        list[UnplacedPallet] | None,
        Field(
            alias="unplacedPallets",
            description="Pallets that could not be placed into containers.",
        ),
    ] = None
    splits: Annotated[
        list[SplitAssignment] | None,
        Field(description="Item-to-container assignments with pallet audit trails."),
    ] = None
    stats: PackStats


class PackRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    items: Annotated[
        list[ItemInput],
        Field(
            description="Items to pack (expanded by quantity). Maximum items per request is plan-dependent (free 100, paid 1000).",
            max_length=1000,
            min_length=1,
        ),
    ]
    bins: Annotated[
        list[BinInput],
        Field(
            description="Bin templates to pack into. Maximum bin types per request is plan-dependent (free 50, paid 200).",
            max_length=200,
            min_length=1,
        ),
    ]
    allow_unplaced: Annotated[
        bool | None,
        Field(
            alias="allowUnplaced",
            description="When false, the request fails if any item cannot be placed. Defaults to true.",
        ),
    ] = None
    objective: Annotated[
        Objective | None,
        Field(
            description="Packing objective (speed, bins used, placed count, waste minimization, cost, or shipping). minCost requires bin cost values; shipping requires bin shipping profiles. Defaults to 'fast'."
        ),
    ] = None
    shipping_objective: Annotated[
        ShippingObjectiveInput | None,
        Field(
            alias="shippingObjective",
            description="Weights for shipping-aware optimization. Used when objective=shipping; can also tune shipping scoring while using other objectives.",
        ),
    ] = None
    palletization: Annotated[
        PalletizationInput | None,
        Field(
            description="Two-stage packing (items->pallets->containers). Returns pallet results and split assignments. (Paid plan only)"
        ),
    ] = None
    include_instructions: Annotated[
        bool | None,
        Field(
            alias="includeInstructions",
            description="If true, returns step-by-step packing instructions for each bin. (Paid plan only) Defaults to false.",
        ),
    ] = None
    label_format: Annotated[
        LabelFormat | None,
        Field(
            alias="labelFormat",
            description="If 'zpl', generates a ZPL label string for each bin. (Paid plan only) Defaults to 'none'.",
        ),
    ] = None
    nesting_strategy: Annotated[
        NestingStrategy | None,
        Field(
            alias="nestingStrategy",
            description="Controls pre-pack nesting. auto uses the main objective to decide nesting; maximize fills cavities first; none disables nesting. Defaults to 'auto'.",
        ),
    ] = None
